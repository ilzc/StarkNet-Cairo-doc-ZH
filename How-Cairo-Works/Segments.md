# 段

## [基本原理](#fundamental)
您可能还记得，Cairo 的内存必须是连续的。然而，程序的某些部分可能是单独连续的，但长度不同，仅在运行时计算 - 事实上，它们的大小只有在程序终止后才能知道。

为此，在 Cairo VM 运行期间，将内存视为连续段的列表很有用，这些段在运行结束时连接形成一个连续的块，此时可以计算它们的最终大小。

## [可重定位值](#relocatable-values)
段内每个内存单元的绝对地址只能在 VM 运行结束时确定。因为这些地址本身可以存储在内存单元中，VM 需要一种方法来引用它们。这是使用可重定位值实现的，表示为 <segment>:<offset>，其中 <segment> 是段号，在运行开始时任意分配，<offset> 是段内存储单元的偏移量。

请注意，由于段编号是任意分配的，因此不能保证该编号在不同程序中甚至在同一程序的不同运行中代表相同的段。

## [用例](#use-cases)
程序段和执行段
Cairo 程序本身保存在内存中，即所谓的程序段中。 该段是固定长度的，包含 Cairo 的数字表示。 程序计数器 pc 从程序段的开头开始。

除此之外，任何 Cairo 程序都需要一个执行段。 这是寄存器 ap 和 fp 开始的地方，也是存储 Cairo 程序运行期间生成的数据（变量、函数调用的返回地址等）的地方。

执行段的长度是可变的，例如，它取决于程序输入。

## [内置段](#internal-segment)
正如您将在内置函数和隐式参数部分看到的那样，每个内置函数在内存中都有自己的连续区域。 该内存位于其自己的段中，该段的长度是可变的。

### 例子
编译以下代码并使用 `--layout=small` `--print_memory ` `--print_info` `--print_segments` 运行它（并且不使用 `--relocate_prints`）：

```
%builtins output

func main(output_ptr: felt*) -> (output_ptr: felt*) {
    [ap] = output_ptr, ap++;
    %{
        print('ap =', ap)
        print('[ap - 1] =', memory[ap - 1])
        print()
    %}
    assert [output_ptr] = 12;
    return (output_ptr=output_ptr + 1);
}
```

段出现在输出中的几个地方。 
提示输出：

```
ap = 1:4
[ap - 1] = 2:0
```

提示打印 `ap` 的值，然后打印 `ap - 1` 处的内存单元的值，在上面的行中将 `output_ptr` 分配给该内存单元。 观察ap寄存器的值是可重定位值1:4。 通常，段 1 是执行段（回想一下，ap 从执行段开始）。 另一方面，它指向的值，即输出内置指针，位于它自己的段 2 中。

段再次出现在内存输出中：

```
Addr  Value
-----------
⋮
0:0   5191102247248822272
0:1   5189976364521848832
0:2   12
0:3   4612389708016484351
0:4   5198983563776458752
0:5   1
0:6   2345108766317314046
⋮
1:0   2:0
1:1   3:0
1:2   4:0
1:3   2:0
1:4   12
1:5   2:1
⋮
2:0   12

Program output:
  12

Number of steps: 5 (originally, 5)
Used memory cells: 14
Register values after execution:
pc = 4:0
ap = 1:6
fp = 3:0
```

内存分为三段：

段 0：程序段。 该段包含程序的编译字节码。

段 1：执行段。 该段包含程序运行期间保存在内存中的值。 请注意，其中大多数表示指针，因此它们本身就是可重定位的值。 出现两次的常数 12 是唯一的例外。

段 2：输出内置段。 此段包含写入输出的唯一值 12。

寄存器的最终值也是可重定位的。 ap 保留在执行段中，而 fp 和 pc 的返回值由于技术原因被赋予它们自己的段。

最后，段重定位表描述了重定位后段开始的真实地址：

```
Segment relocation table:
0     1
1     8
2     14
3     15
4     15
```

段 3-4 是用于 fp 和 pc 的返回值的空段。 观察每个段的开始都映射到前面段的长度之和。 这使整个内存保持连续。

### 练习
再次运行相同的程序，这次使用标志 `--relocate_prints`，它将在重定位后打印相同的值。

重定位的内存和寄存器值确实对应于可重定位的值，根据段重定位表重定位。

为什么从提示（前两行）打印的值仍然可以重定位？ 是否可以从相同的提示打印它们的重定位值？