# 程序计数器 (pc)

## [程序计数器和跳转](#counter-and-jump)

程序是存储在内存中，每条指令会有 1 到 2 个字段元素（例如，当指令中存在立即数时，会出现两个字段元素，而第二个是立即数）。

程序计数器 (pc) 保存了执行到当前位置的指令地址。通常情况下，它根据指令的大小每条指令前进 1 或 2 （当指令占用两个字段元素时，程序计数器会前进 2）

`jmp` 指令可以跳转到其他位置执行不同的指令。`jmp` 提供三种跳转方式：

1.绝对位置跳转：跳转到给定地址（通过将程序计数器更改为给定值）。 例如，`jmp abs 17；` 将 `pc` 更改到绝对位置 17。

2.相对位置跳转: 跳转到当前指令的偏移量。 例如 `jmp rel 17；` 将 `pc` 变为 `pc + 17`。注意 `pc` 指的是当前指令的程序计数器的值。 因此，一个特例是指令 `jmp rel 0；` 它跳到自己，从而创建一个无限循环。

3.跳转到标签位置: 这转化为相对跳转，其中 Cairo 编译器自动计算当前指令和标签之间的差异。 这是最常用（并且可读性强）的跳转。

### 练习
下面的代码做了什么事情？（运行时用  `--no_end` `--step=16` 来避免 End of program was not reached 错误）

```
func main() {
    [ap] = 2, ap++;

    my_loop:
    [ap] = [ap - 1] * [ap - 1], ap++;
    [ap] = [ap - 1] + 1, ap++;
    jmp my_loop;
}
```

### 更多练习
下面的代码做了什么事情？ (可以看一下运行时的内存情况; 注意使用 `--no_end` flag)

```
func main() {
    [fp + 1] = 2, ap++;
    [fp] = 5201798304953761792, ap++;
    jmp rel -1;
}
```

## [条件跳转](#condition-jump)

另一种重要的指令是条件跳转。指令的语法时 `jmp <label> if [<expr>] != 0;` 当表达式 <expr> 是 `ap + offset` 或者 `fp + offset` (offset 是可以省略)。如果对应的内存值不为零，Cairo 将跳转到给定的标签。 否则，它将正常继续下一条指令。 除了使用标签，您还可以使用 `rel <expr>` 以类似于常规跳转的方式（例如 `jmp rel 17 if [ap - 1] != 0;`）。

### 练习

改写上述练习中的循环 my_loop，使其从向 [ap] 写入 10 开始，继续写入递减序列，然后返回。 不要忘记 ret 指令。 通过查看内存来验证您的代码是否按预期工作。