#  **Cairo** 介绍

## 字段

在现代 CPU 中，基本的数据类型是 64 位整数。在数学上，我们可以用取模 $2^{64}$ 。例如，-17 可以表示为 $2^{64} - 17$ 而且确信 $-17≡2^{64} - 17 (mod 2^{64})$ ，同时 $2^{63}$ 乘以 2 我们会得到 0。
在Cairo语言中,基础的数据类型在区间 $0 \le x \lt P$ (其中 $P$ 是质数)的整数（例如, $P = 2^{251} + 17*2^{192} + 1$就是一个标准选项。所有的计算都以 P 作为模数。

在一些例子里，它对代码没有影响：如果你写一个循环计算 1,2,3,...,1000 之和，因为计算在范围之内（注意 $P$ 可能会大于 $2^{64}$，因此一个很大的值可以存储在一个元素中），所以不会发生溢出。在一些情况下，你需要在常规 CPU 中防止溢出。

在另一方面，有一些情况，模数 $P$ 需要更多注意的地方：
1.除法 - 不像常规的 CPU 中的整数相处定义为 $x/y$ (例如 $ 7/2 = 3$ )，它可能不满足 $(x/y)*y == x$。如果 y 整除 x作为整数，你会在Cairo中获得预期的结果（例如 $6/2$ 会等于 3）。但是如果 y 不能整除 x，你可能会获得意外的结果：例如， $2*(p+1)/2=P+1=1(mod P)$ ，值 1/2 在 Cairo 中是 $(P+1)/2$（而不是 0 或者 0.05）
2.检查一个值是否偶数：在常规 CPU 中，如果你去一个值 x 并且乘以 2，结果一定是偶数。但这个在Cairo中是不成立的，正如我们之前看到，如果我们的 $(P+1)/2$ 乘以 2 我们得到 1 ，这个实际上是一个奇数。实际上，这个属性实在CPU中“偶然”发生的。我们尝试概括一下，将 x 乘以 3 并补总是会得到一个可被 3 整除的数字（尝试运行下面的C++代码：std::cout << 12297829382473034411U * 3 << std::endl;）

## 非确定性计算
由于Cairo的目标是证明某些计算是正确的，因此我们有时可以走捷径。例如，考虑我们的目标是证明平方根y，$x=961$是在范围0,1,...,100。直接的方法是编写一个从 961 开始的复杂代码，计算其根并验证该根是否在所需范围内。但是我们可以做一些更简单的事情，简单地证明我们从 31 开始并平方我们得到 961（并验证 31 在范围内）。这意味着我们可以从解决方案（31）开始，而不是从输入（961）开始。 我们将此方法称为非确定性计算（可以在[此处](https://en.wikipedia.org/wiki/NP_(complexity))了解）。

伪代码如下：
1.神奇地猜测 $y$ 值（这是不确定的部分）
2.计算 $y^2$ 并且保证结果是等于 $x$ 
3.验证 $y$ 是否在范围内

你将会学到怎么用Cairo编写程序来实现这些特性，在[提示]()和[非确定性跳转]()中可以了解到

### 练习：
1.编写非确定性计算的伪代码来证明等式 $x^7+x+18=0$ 是有解。
2.编写非确定性计算的伪代码来证明上面提到的等式最少是有两个解。

## 内存模型
Cairo支持只读的非确定性内存，这意味着每个内存单元的值是有证明者来确定，但他不能随时间改变（在Cairo程序执行期间）。我们使用语法 [x] 代表 内存地址 x 的值。例如，我们在程序开始的时候断言 [0] = 7，那么 [0] 将会在整个运行期间的值将是7.

通常将内存视为一次性卸乳是很方便的：你可以将一个值写入内存单元中一次，但以后不能更改它。 因此，我们可以将断言 [0] == 7 的指令解释为“从地址 0 处的存储单元读取值并验证是否得到 7”或“将值 7 写入该存储单元”，具体取决于 上下文（在只读的非确定性内存模型中，它们的含义相同）。

## 寄存器
在指定的寄存器中是有可以随时间变化的值：
1.ap (分配指针) - 指向还没有被使用的内存单元.
2.fp（帧指针）— 指向当前函数的帧。 所有函数的参数和局部变量的地址都与该寄存器的值相关。当一个函数启动时，它等于 ap。但与 ap 不同的是，fp 的值在整个函数范围内保持不变。将在 [fp 寄存器]() 中了解有关 fp 的更多信息。

pc（程序计数器）- 指向当前指令。

# 基础指令
一个简单的 Cairo 指令采用等式断言的形式。 例如：
```
[ap] = [ap - 1] * [fp], ap++;
```
声明两个存储单元（`[ap - 1]` 和 `[fp]`）的乘积必须与下一个未使用单元（`[ap]`）的值相同。 我们认为这是将两个值的乘积“写入”到 `[ap]` 中。 后缀 `ap++` 告诉 Cairo 在执行指令后将 ap 加一（要以除 ap++ 以外的任何方式更改 ap，您必须使用指定的指令 `ap += ...`）。 `ap++` 本身并不是一条指令——它是出现在逗号之前的指令的一部分。 逗号语法是 `ap++` 独有的，不能用于分隔两条指令。

下面的列表展示了我们在 Cairo 中有效的 assert-equal 指令：
```
[fp - 1] = [ap - 2] + [fp + 4];
[ap - 1] = [fp + 10] * [ap], ap++;
[ap - 1] = [fp + 10] + 12345, ap++;  // 查看 (a) 解释.
[fp + 2] = [ap + 5];
[fp + 2] = 12345;
[ap + 2] = [[ap + 5]];  // 查看 (b) 解释.
[ap] = [fp - 3] - [ap + 4];  // 查看 (c) 解释.
[ap] = [fp - 3] / [ap + 4];  // 查看 (c) 解释.
```
a.指令中可能出现两种类型的整数：
  - 立即数，既可以作为给定操作中的第二个操作数（例如 `[ap - 1] = [fp + 10] + 12345;` 中的 `12345`），也可以作为赋值的独立值（例如 `[fp + 2] = 12345;`）。

  - 偏移量，出现在括号内（例如 `[ap + 5]` 中的 `5` 或 `[fp - 3]` 中的 `-3`）。
  
  立即数可以是任何字段元素，而偏移量限制在范围 $[-2^{15}, 2^{15})$ 内。

b.指令 `[ap + 2] = [[ap + 5]]`; 是一个双重取消引用指令，您可以在其中获取值 `[ap + 5]` 并将其视为内存的地址。

c.这些指令是语法糖——它们分别被替换为 `[fp - 3] = [ap] + [ap + 4]; [fp - 3] = [ap] * [ap + 4]`。

Cairo 还支持一种高级语法，它允许用户编写涉及多个操作的语句，正如将在断言语句和复合表达式中看到的那样。

### 例子 - 一个 Cairo 示例
编写一组代码计算下列多项式并保存为 poly.cairo 
$x^3+23x^2+45x+67, x=100$
1.当程序结束时，值需要存储在 `[ap - 1]` 中。
2.对于本练习，可以假设 `fp` 寄存器是常量并初始化为与 `ap` 相同的值。

使用以下代码模板：
```
func main() {
    [ap] = 100, ap++;
    // 在此编写代码

    ret;
}
```

3.代码不能依赖于 `x` 的值

4.奖励：这可以使用 5 条指令完成，不包括模板中给出的指令。

5.使用 `cairo-compile` 编译并检查输出。 输出应该在 `poly_compiled.json` 中。

6.运行程序（这将调用 Cairo VM）：
```
cairo-run \
--program=poly_compiled.json --print_memory --print_info \
--trace_file=poly_trace.bin --memory_file=poly_memory.bin \
--relocate_prints
```
查看输出：可以看到内存值（最后一个单元格应该是 1234567）。验证您是否了解那里执行的事情。

## 连续内存
Cairo 有一个技术要求，即程序访问的内存地址必须是连续的。 例如，如果访问地址 7 和 9，那么在程序结束之前也必须访问 8（访问顺序无关紧要）。 如果地址范围中存在小间隙，证明者将自动用任意值填充这些地址。 一般来说，有这样的差距是低效的，因为这意味着内存被消耗而不被使用。 引入太多的漏洞可能会使生成证明的成本过于昂贵，以至于诚实的证明者无法执行。 然而，这仍然没有违反健全性保证——无论如何都不能生成错误的证明。

### 练习
1.运行以下程序：
```
func main() {
    [ap] = 100;
    [ap + 2] = 200;
    ret;
}
```
解释为什么这个程序的执行会产生内存间隙，从而导致效率低下（鉴于您刚刚在上一节中读到的内容）。 在函数末尾（就在 ret 之前）添加一条指令，这样就不会出现内存间隙。

2.下面的代码有什么问题？
```
func main() {
    [ap] = 300;
    [ap + 10000000000] = 400;
    ret;
}
```