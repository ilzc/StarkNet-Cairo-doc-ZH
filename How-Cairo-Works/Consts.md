# 常量和引用

## [常量](#const)

Cairo 支持定义常量表达式（仅限整数）。 例如，可以写：

```
const value = 1234;
[ap] = value;
```

等价于

```
[ap] = 1234;
```

`const value = 1234` 不会转换为 Cairo 指令； 它只是被编译器用来在指令中将 `value` 替换为 `1234`。

## [短字符串文字](#Short-string-literals)

短字符串是长度最多为 31 个字符的字符串，因此可以放入单个字段元素中。

```
[ap] = 'hello';
```

等价于
```
[ap] = 0x68656c6c6f;
```

重要的是要注意，短字符串只是表示字段元素的一种方式，它不是真正的字符串。 Cairo 目前不支持字符串，当它支持时，字符串将使用 " 而不是 ' 表示（类似于 C/C++ 中的区别）。

字符串的第一个字符是整数的最高有效字节（大端表示）。

# [引用](#references)

有时可能很难跟踪 ap 寄存器的位置。 考虑以下代码，它计算 $x^{16}+x$ 当 $x=3$ :

```
[ap] = 3, ap++;

[ap] = [ap - 1] * [ap - 1], ap++;
[ap] = [ap - 1] * [ap - 1], ap++;
[ap] = [ap - 1] * [ap - 1], ap++;
[ap] = [ap - 1] * [ap - 1], ap++;

[ap] = [ap - 1] + [ap - 5], ap++;
```

`let` 语法定义了一个引用，并且此代码编译为与前面代码完全相同的指令。 特别是，编译器将第一次出现的 [x] 替换为 [ap]，第二次替换为 [ap - 5]。 换句话说，编译器跟踪 ap 寄存器的进程并相应地替换 x。

引用可以包含任何 Cairo 表达式，例如：

```
let x = [[fp + 3] + 1];
[ap] = x; 
```

## [断言和复合表达式](#assert)

通常，您需要执行涉及多个操作的计算。 练习 [一个简单的 Cairo 程序]()就是一个很好的例子。 涉及多个操作的表达式（例如，[ap] * [ap] * [ap], [[[ap]]] + [ap], ...）称为复合表达式。 Cairo 编译器支持以下语法，它允许断言两个复合表达式的值之间的相等性：

```
assert <expr> = <expr>;
```

例如：
```
let x = [ap - 1];
let y = [ap - 2];
assert x * x = x + 5 * y;
```
请注意，此类语句通常编译为多条指令，并且 `ap` 可能会有未知数量的步骤（确切数量取决于两个复合表达式中的操作数量）。 因此，您应避免在此类表达式中直接使用 `ap` 和 `fp`，而应使用本节中介绍的机制（引用和临时/局部变量）。

## [撤销引用](#revoked-references)
请注意，如果在依赖于 ap 的引用定义及其用法之间存在标签或调用指令（调用另一个函数。请参阅[函数]()），则该引用可能会被撤销，因为编译器可能无法计算 `ap` 的变化（因为人们可能会从程序中的另一个位置跳转到标签，或者调用可能以未知方式更改 `ap` 的函数）。

在某些情况下，编译器不会自动检测到可能发生跳转（例如，在显式相对跳转中，请参见下面的练习）并且不会撤销引用。 但是，在这种情况下使用此引用可能会导致未定义的行为。

不依赖于 `ap` 的引用（例如，`let x = [[fp]];`）永远不会被编译器撤销，但同样的规则适用——在定义它们的函数范围之外使用这些引用，可能 导致未定义的行为。

### 练习

使用 `--steps=32 --print_memory` 运行以下代码并解释发生了什么。

```
func main() {
    let x = [ap];
    [ap] = 1, ap++;
    [ap] = 2, ap++;

    [ap] = x, ap++;
    jmp rel -1;  // 跳转到前面的指令
}
```

## [类型引用](#type-reference)

假设 `[fp]` 包含一个指向三个内存单元的结构的指针：x、y、z。 要访问 y 的值，可以写为 `[[fp] + 1]`。 但是，这需要程序员维护 y 的偏移量。

更好的方法是定义一个结构：

```
struct MyStruct {
    x: felt,
    y: felt,
    z: felt,
}
```

这将创建一个名为 MyStruct 的结构。 关键字 `felt` 代表字段元素，它是 Cairo 的原始类型。 Cairo 编译器从结构的开头计算成员的偏移量，您可以使用 MyStruct.x、MyStruct.y 和 MyStruct.z 访问这些偏移量（例如 MyStruct.z = 2）。 此外，可以使用 MyStruct.SIZE 获得结构的总大小。 现在我们可以将 `[[fp] + 1]` 替换为 `[[fp] + MyStruct.y]`。

```
let ptr: MyStruct* = cast([fp], MyStruct*);
assert ptr.y = 10;
// 这将编译成 [ptr + MyStruct.y],
// 随后将编译为 [[fp] + 1]。
```

通常，语法 `refname.member_name` 编译为 `[val + T.member_name]`，其中 refname 是值 val 和类型 T 的类型化引用，而 T.member_name 是成员定义。

您可以省略类型并编写（Cairo 编译器将从右侧推断类型）：

```
let ptr = cast([fp], MyStruct*);
```

## [类型转换](#cast)
每个 Cairo 表达式都有一个关联的类型。 Cairo 支持字段元素（由关键字 felt 表示）、指针和结构等类型。 例如，寄存器 ap 和 fp 的值的类型以及任何整数都是felt类型。

您可以使用 cast(<expr>, <type>) 转换表达式的类型，其中<type> 可以是felt类型（对于字段元素）、T（对于结构 T，如上所述）或指向 另一种类型（如 T* 或 felt**）。


## [临时变量](#tempvar)

Cairo 支持以下允许定义临时变量的语法糖：

```
tempvar var_name = <expr>;
```

对于简单的表达式，最多只有一次操作，这相当于：

```
[ap] = <expr>, ap++;
let var_name = [ap - 1];
```

还支持复合表达式，在这种情况下，命令可以编译为多个 Cairo 指令。

请注意，由于引用是基于 ap 的，它可能会被一些指令撤销（参见撤销的引用）。

### 练习

重写练习 [一个使用临时变量的简单 Cairo 程序]()

## [局部变量](#local-variables)

另一个重要特性称为“局部变量”。 与基于 `ap` 寄存器的临时变量不同，因此会被某些指令撤销（请参阅已撤销的引用），局部变量基于 `fp` 寄存器。 在函数范围内，第一个局部变量是对 `[fp + 0]` 的引用，第二个是对 `[fp + 1]` 的引用，依此类推。 与负责递增 ap 的临时变量不同，局部变量并非如此。 如果您使用局部变量，则必须注意提前 ap。 Cairo 编译器自动生成一个常量 SIZEOF_LOCALS，它等于同一范围内本地变量的累积大小（单元格）。 例如：

```
func main() {
    ap += SIZEOF_LOCALS;
    local x;  // x 相当于 [fp + 0].
    local y;  // y 相当于 [fp + 1].

    x = 5;
    y = 7;
    ret;
}
```

此外，Cairo 提供了指令 `alloc_locals`，该指令被转换为 ap += SIZEOF_LOCALS。

您还可以在一行中定义一个局部变量并为其赋值：

```
local x = <expr>;
```

实际上，表达式可能是复合表达式。

请注意，除非在同一行中初始化局部变量，否则 `local` 指令本身不会转换为 Cairo 指令（这是与 `tempvar` 的另一个区别）——它只是转换为引用定义。 这是您必须手动增加 ap 值的原因之一。

局部变量可能具有类型，例如引用。 在当前版本的 Cairo 中，必须明确说明局部变量的类型（否则使用felt），并且不是从初始化值的类型推导出来的。

### 练习
1. 下面的代码有什么问题？ （提示：尝试用 alloc_locals 替换 ap += SIZEOF_LOCALS; 看看会发生什么）你能在不改变代码中变量定义顺序的情况下修复它吗？

```
func main() {
    tempvar x = 0;

    local y;
    ap += SIZEOF_LOCALS;
    y = 6;
    ret;
}
```

2. 你能在下面的代码中发现效率低下的地方吗？ 提示：看看[这里](Introduction-to-Cairo.md#continues-memory)。 通过两种方式修复效率低下（分别实现以下修复）：

移动指令 alloc_locals;。

使用 tempvar 而不是 local。

```
func pow4(n) -> (m: felt) {
    alloc_locals;
    local x;

    jmp body if n != 0;
    [ap] = 0, ap++;
    ret;

    body:
    x = n * n;
    [ap] = x * x, ap++;
    ret;
}

func main() {
    pow4(n=5);
    ret;
}
```

## [类型化的局部变量](#typed-local-vars)

您可以通过两种不同的方式为局部变量指定类型：

```
local x: T* = <expr>;
local y: T = <expr>;
```

第一个分配一个单元格，它将被视为指向 T 类型的结构的指针。因此，您可以将 `x.a` 用作 `[[fp + 0] + T.a]` 的等价物（假设 a 是 T 的成员）。

第二个分配 `T.SIZE` 单元（由于 x 的定义，在上例中从 `fp + 1` 开始），在这种情况下 y.a 等价于 `[fp + 1 + T.a]` 而不是 `[[fp + 1] + T.a]`（练习：为什么？）。

此外，y 本身指的是结构的地址（fp + 1 而不是 [fp + 1]）。 这意味着如果您尝试使用 y，您可能会遇到错误。 例如：

```
tempvar z = y;
```

将失败，因为它应该编译为 assert `[ap] = fp + 1, ap++;` 由于使用 `fp`，这在开罗不是有效的指令。 尽管如此，定义一个名为 `__fp__` 的变量将允许代码编译，正如您将在访问寄存器的值中看到的那样。

## [引用重绑定](#Reference-rebinding)

Cairo 允许您使用现有引用的名称定义引用：

```
let x: T* = cast(ap, T*);
x.a = 1;

// ...

// 重新绑定 x  到 fp + 3.
let x: T* = cast(fp + 3, T*);
x.b = 2;
```

引用不是变量：每个定义的范围是根据对指令执行顺序的静态分析来定义的。 它将遵循跳转和条件跳转的基本流程，但如果同一引用存在冲突定义，则该引用将被撤销。

### 例子

为了强调最后一点，请考虑以下代码。

```
func foo(x) {
    let y = 1;
    jmp x_not_zero if x != 0;

    x_is_zero:
    [ap] = y, ap++;  // y == 1.
    let y = 2;
    [ap] = y, ap++;  // y == 2.
    jmp done;

    x_not_zero:
    [ap] = y, ap++;  // y == 1.
    let y = 3;
    [ap] = y, ap++;  // y == 3.

    done:
    ret;
}
```

此代码将返回 [1, 2] 或 [1, 3]。

## [元组](#tuples)

元组允许方便地引用有序的元素集合。 元组由有效类型的任意组合组成，包括其他元组。

元组表示为用括号括起来的以逗号分隔的元素列表。 例如：(3, x)。

考虑以下断言语句：

```
assert (x, y) = (1, 2);
```

上面的语句编译为：

```
assert x = 1;
assert y = 2;
```

有关元组表达式类型的更多信息，请参阅[元组](Types.md#tuple)。

使用元组表达式访问元组元素，后跟括号，该括号包含元素的从零开始的索引。 索引必须在编译时已知。

```
let a = (7, 6, 5)[2];  // let a = 5;
```

Cairo 要求单元素元组的尾随逗号，以将它们与常规括号区分开来。 例如 (5,) 是一个单元素元组。 通过使用从最外层元组开始的附加索引来访问嵌套元组。 例如，`MyTuple[2][4][3][1]` 首先访问 MyTuple 的索引 2。 该值在索引 4 处访问，依此类推。

## [数组](#array)

为了在 Cairo 中表示一个数组（同质元素的有序集合），可以使用指向数组开头的指针。 请参阅 [alloc()](Object-Allocation.md#alloc) 为数组分配新的内存段。

表达式 `struct_array[n]` 用于访问数组的第 n 个元素，其中 n=0 是第一个元素。 `struct_array[index]` 被编译为 `[struct_array + index * MyStruct.SIZE]`，并且是 MyStruct 类型。